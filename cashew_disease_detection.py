# -*- coding: utf-8 -*-
"""cashew disease detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/104PHWrFXJtdjT2U_0IxHf6-BTop_9ZFg
"""

path="/content/data"

from google.colab import drive
drive.mount('/content/drive')

!unzip /content/drive/MyDrive/data.zip

import tensorflow_hub as hub
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import tensorflow as tf

import os
from keras.utils import to_categorical
import os
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

dataset_path = "/Users/akshaykumar/Downloads/Data/train/train/images"
dataset_path_txt = "/Users/akshaykumar/Downloads/Data/train/train/labels"

# Set the path to the directory containing the images

image_files = [f for f in os.listdir(dataset_path) if f.endswith(".jpg") or f.endswith(".png")]
txt_files = [f for f in os.listdir(dataset_path_txt) ]

num_images_to_display = 5

for i in range(num_images_to_display):
    img_path = os.path.join(dataset_path, image_files[i])
    img = mpimg.imread(img_path)

    txt_path = os.path.join(dataset_path_txt, txt_files[i])

    # Display the image
    plt.imshow(img)
    plt.axis('off')  # Turn off axis labels
    plt.show()

    with open(txt_path, 'r') as file:
        file_content = file.read()
        print(f"Content of {txt_files[i]}:\n")
        print(file_content)

# import cv2
# import matplotlib.pyplot as plt
# import matplotlib.patches as patches

# # Load the image
# image_path = "path/to/your/image.jpg"
# image = cv2.imread(image_path)

# # Bounding boxes in COCO format [x, y, width, height]
# # Example: [x1, y1, width1, height1], [x2, y2, width2, height2], ...
# bounding_boxes = [[100, 50, 50, 75], [200, 100, 30, 40], [300, 200, 80, 60]]

# # Create figure and axes
# fig, ax = plt.subplots(1)

# # Display the image
# ax.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))

# # Add bounding boxes to the image
# for bbox in bounding_boxes:
#     x, y, width, height = bbox
#     rect = patches.Rectangle((x, y), width, height, linewidth=2, edgecolor='r', facecolor='none')
#     ax.add_patch(rect)

# # Show the image with bounding boxes
# plt.show()

def getRect(values, image_height,image_width):
#     print(values)
    class_label = values[0]
    x_center, y_center, width, height = map(float, values[1:])
    x_absolute = int(x_center * image_width)
    y_absolute = int(y_center * image_height)
    width_absolute = int(width * image_width)
    height_absolute = int(height * image_height)
    return [class_label,x_absolute,y_absolute,width_absolute,height_absolute]



import cv2
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import json

image_list = os.listdir(dataset_path)
labels_list = os.listdir(dataset_path_txt)
classes={}
for i,image_name in enumerate(image_list):
    print(image_name)
    try:
        image=cv2.imread(os.path.join(dataset_path,image_name))
    #     image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)


        text_file_path = os.path.join(dataset_path_txt,labels_list[i])

        with open(text_file_path, 'r') as file:
            lines = file.readlines()

        bounding_boxes = []
        labels = []
        floats=[]
        for num,line in enumerate(lines):
            values = line.strip().split(' ')
            floats = [float(value) for value in values]
            floats=getRect(floats,image.shape[0],image.shape[1])

    #     classes[image_name]=getRect(floats,image.shape[0],image.shape[1])
            x1 = floats[1]
            y1 = floats[2]
            x2 = floats[1] + floats[3]
            y2 = floats[2] + floats[4]


            cropped_image = cv2.resize(image[y1:y2, x1:x2],(224,224))[:,:,::-1]
    #         print(cropped_image.shape)
            cv2.imwrite(os.path.join(path,os.path.splitext(image_name)[0]+"."+str(num)+".png"), np.array(cropped_image))
#     print(classes)
#             if image_name in classes:
            classes[os.path.splitext(image_name)[0]+"."+str(num)+".png"]=floats[0]
#             else:
#                 classes[image_name]=list(floats)
    except:
        print("failed")

with open(os.path.join(path,"classes.json"), 'w') as json_file:
    json.dump(classes, json_file)

layer=hub.KerasLayer("https://www.kaggle.com/models/tensorflow/efficientnet/frameworks/TensorFlow2/variations/b0-classification/versions/1", trainable=True)
inp=tf.keras.layers.Input((224,224,3))
x=layer(inp)
x=tf.keras.layers.Dropout(0.65)(x)
x=tf.keras.layers.Dense(128,activation="relu")(x)
x=tf.keras.layers.BatchNormalization()(x)
x=tf.keras.layers.Dropout(0.7)(x)
x=tf.keras.layers.Dense(3,activation="softmax")(x)
model=tf.keras.Model(inputs=inp,outputs=x)
model.summary()

with open("/content/classes.json", 'r') as json_file:
            labels = json.load(json_file)

labels

class dataGenerator(tf.keras.utils.Sequence):
    def __init__(self,_location,vid_list,batch_size):
        self.location = _location
        self.batch_size = batch_size
        self.vid_list = vid_list
        self.indexes = np.arange(len(self.vid_list))
        print(len(vid_list))
        with open("/content/classes.json", 'r') as json_file:
            labels = json.load(json_file)

    def __getitem__(self,i):
        start = i * self.batch_size
        end = (i+1) * self.batch_size
        videos_batch = []
        labels_batch = []
        for j in range(start,end):
            item_name = self.vid_list[j]
            buff = cv2.imread(os.path.join(self.location,item_name))
#             print(buff)
            labels_batch.append(to_categorical(int(labels[item_name]),num_classes=3))
#             print(int(labels[item_name]))
            videos_batch.append(buff)
#             print(labels_batch)
        return (np.array(videos_batch), np.array(labels_batch))

    def __len__(self):
        return len(self.indexes) // self.batch_size

import random
img_list=os.listdir(path)
img_list.remove("classes.json")
random.shuffle(img_list)
train_list=img_list[len(img_list)//10:]
val_list=img_list[:len(img_list)//10]
trainGen=dataGenerator(path,train_list,32)
valGen=dataGenerator(path,val_list,32)



model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.00003,weight_decay=0.84),loss='categorical_crossentropy',metrics=['accuracy'])

history=model.fit(trainGen,epochs=10,validation_data=valGen)

plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.show()

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.show()

model.save("model")

model= tf.keras.models.load_model('my_model.keras')

def calculate_iou(box1, box2):

    x1, y1, w1, h1 = box1
    x2, y2, w2, h2 = box2

    intersection_x1 = max(x1, x2)
    intersection_y1 = max(y1, y2)
    intersection_x2 = min(x1 + w1, x2 + w2)
    intersection_y2 = min(y1 + h1, y2 + h2)

    intersection_area = max(0, intersection_x2 - intersection_x1 + 1) * max(0, intersection_y2 - intersection_y1 + 1)
    union_area = w1 * h1 + w2 * h2 - intersection_area

    iou = intersection_area / union_area if union_area > 0 else 0

    return iou

def detection(img_path,confidence=0.5,iou_thresh=0.1):

    img = plt.imread(img_path)
    cv2.setUseOptimized(True);
    # print("o yess")
    ss = cv2.ximgproc.segmentation.createSelectiveSearchSegmentation()
    ss.setBaseImage(img)
    ss.switchToSelectiveSearchFast()
    rects = ss.process()
    sel_rects = rects[:2000]
    # print("Helll")
#     ['abiotic', 'insect', 'disease']

    pred_abiotic=[]
    pred_insect=[]
    pred_disease=[]
    for index, rect in tqdm(enumerate(sel_rects)):
        # print("aha")
        x,y,w,h = rect
        roi = img[y:y+h,x:x+w,:]
        resized_roi = cv2.resize(roi,(224,224))/255


        pred = model.predict(resized_roi.reshape(-1,224,224,3))
        print(pred)
        pred_lab=np.argmax(pred,axis=-1)


        if pred_lab == 0 and np.max(pred)>confidence:
            pred_abiotic.append([list(rect),np.max(pred)])
        elif pred_lab==1 and np.max(pred)>confidence:
            pred_insect.append([list(rect),np.max(pred)])
        elif pred_lab==2 and np.max(pred)>confidence:
            pred_disease.append([list(rect),np.max(pred)])

    final = []

#     abiotic

    if len(pred_abiotic) != 0:
        pred_score_abiotic = [x[1] for x in pred_abiotic]
        pred_bb_abiotic = [x[0] for x in pred_abiotic]

        for i in range(len(pred_abiotic)):
            temp_bb , temp_score = pred_bb_abiotic.copy() , pred_score_abiotic.copy()
            if len(temp_bb) !=0:

                max_score_box = temp_bb[np.argmax(temp_score)]

                if [max_score_box,np.max(temp_score)] not in final:
                    final.append([max_score_box,np.max(temp_score),0])#0 is label
                    index_should_del = []

                    for ind,other_bb in enumerate(temp_bb):
                        iou_score = calculate_iou(max_score_box , other_bb)

                        # Non maximum suppression(nms)

                        if iou_score >= iou_thresh:
                            index_should_del.append(ind)

                    pred_bb_abiotic    = []
                    pred_score_abiotic = []
                    for bb_index ,bb_value in enumerate(temp_bb) :
                        if bb_index not in index_should_del:
                            pred_bb_abiotic.append(bb_value)

                    for score_index ,score_value in enumerate(temp_score) :
                        if score_index not in index_should_del:
                            pred_score_abiotic.append(score_value)
                else:
                    continue

            else:
                break
# exact same for other 2 classes
    if len(pred_insect) != 0:
        pred_score_insect = [x[1] for x in pred_insect]
        pred_bb_insect = [x[0] for x in pred_insect]

        for i in range(len(pred_abiotic)):
            temp_bb , temp_score = pred_bb_insect.copy() , pred_score_insect.copy()
            if len(temp_bb) !=0:

                max_score_box = temp_bb[np.argmax(temp_score)]

                if [max_score_box,np.max(temp_score)] not in final:
                    final.append([max_score_box,np.max(temp_score),1])#0 is label
                    index_should_del = []

                    for ind,other_bb in enumerate(temp_bb):
                        iou_score = calculate_iou(max_score_box , other_bb)

                        # Non maximum suppression(nms)

                        if iou_score >= iou_thresh:
                            index_should_del.append(ind)

                    pred_bb_insect    = []
                    pred_score_insect = []
                    for bb_index ,bb_value in enumerate(temp_bb) :
                        if bb_index not in index_should_del:
                            pred_bb_insect.append(bb_value)

                    for score_index ,score_value in enumerate(temp_score) :
                        if score_index not in index_should_del:
                            pred_score_insect.append(score_value)
                else:
                    continue

            else:
                break

    #next

    if len(pred_disease) != 0:
        pred_score_disease = [x[1] for x in pred_disease]
        pred_bb_disease = [x[0] for x in pred_disease]

        for i in range(len(pred_disease)):
            temp_bb , temp_score = pred_bb_disease.copy() , pred_score_disease.copy()
            if len(temp_bb) !=0:

                max_score_box = temp_bb[np.argmax(temp_score)]

                if [max_score_box,np.max(temp_score)] not in final:
                    final.append([max_score_box,np.max(temp_score),2])#0 is label
                    index_should_del = []

                    for ind,other_bb in enumerate(temp_bb):
                        iou_score = calculate_iou(max_score_box , other_bb)

                        # Non maximum suppression(nms)

                        if iou_score >= iou_thresh:
                            index_should_del.append(ind)

                    pred_bb_disease   = []
                    pred_score_disease = []
                    for bb_index ,bb_value in enumerate(temp_bb) :
                        if bb_index not in index_should_del:
                            pred_bb_disease.append(bb_value)

                    for score_index ,score_value in enumerate(temp_score) :
                        if score_index not in index_should_del:
                            pred_score_disease.append(score_value)
                else:
                    continue

            else:
                break



    imOut = img.copy()
    for rect,score,cls in final:

        x,y,w,h = rect
        if cls == 0:
            color =(255,0,0)
        if cls == 1:
            color = (0,255,0)
        if cls == 2:
            color = (0,0,255)

        cv2.rectangle(imOut,(x,y),(x+w,y+h),color,2)

        cv2.putText(imOut,str(cls)+':'+str(round(score*100,2)),(x,y-8),cv2.FONT_HERSHEY_SIMPLEX,1, color, 2, cv2.LINE_AA)
    plt.imshow(imOut)
    cv2.imwrite('prediction.jpeg',imOut)


    return final

detection("/content/7.jpg")

